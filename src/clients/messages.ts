export default {
  clients: {
    protocol: {
      openIdConnect: "OpenID Connect",
      saml: "SAML",
    },
    clientType: "Client type",
    clientAuthorization: "Authorization",
    implicitFlow: "Implicit flow",
    createClient: "Create client",
    importClient: "Import client",
    homeURL: "Home URL",
    webOrigins: "Web origins",
    addWebOrigins: "Add web origins",
    adminURL: "Admin URL",
    formatOption: "Format option",
    encryptAssertions: "Encrypt assertions",
    clientSignature: "Client signature required",
    downloadAdaptorTitle: "Download adaptor configs",
    privateKeyMask: "PRIVATE KEY NOT SET UP OR KNOWN",
    keys: "Keys",
    credentials: "Credentials",
    roles: "Roles",
    createRole: "Create role",
    noRoles: "No roles for this client",
    noRolesInstructions:
      "You haven't created any roles for this client. Create a role to get started.",
    clientScopes: "Client scopes",
    addClientScope: "Add client scope",
    addClientScopesTo: "Add client scopes to {{clientId}}",
    clientScopeRemoveSuccess: "Scope mapping successfully removed",
    clientScopeRemoveError: "Could not remove the scope mapping {{error}}",
    clientScopeSuccess: "Scope mapping successfully updated",
    clientScopeError: "Could not update the scope mapping {{error}}",
    searchByName: "Search by name",
    setup: "Setup",
    evaluate: "Evaluate",
    assignRole: "Assign role",
    unAssignRole: "Unassign",
    removeMappingTitle: "Remove mapping?",
    removeMappingConfirm_one: "Are you sure you want to remove this mapping?",
    removeMappingConfirm_other:
      "Are you sure you want to remove {{count}} mappings",
    clientScopeSearch: {
      name: "Name",
      type: "Assigned type",
      protocol: "Protocol",
    },
    assignedClientScope: "Assigned client scope",
    assignedType: "Assigned type",
    hideInheritedRoles: "Hide inherited roles",
    inherentFrom: "Inherited from",
    emptyClientScopes: "This client doesn't have any added client scopes",
    emptyClientScopesInstructions:
      "There are currently no client scopes linked to this client. You can add existing client scopes to this client to share protocol mappers and roles.",
    emptyClientScopesPrimaryAction: "Add client scopes",
    scopeParameter: "Scope parameter",
    scopeParameterPlaceholder: "Select scope parameters",
    effectiveProtocolMappers: "Effective protocol mappers",
    effectiveRoleScopeMappings: "Effective role scope mappings",
    generatedAccessToken: "Generated access token",
    searchForProtocol: "Search protocol mapper",
    parentClientScope: "Parent client scope",
    searchForRole: "Search role",
    origin: "Origin",
    user: "User",
    noGeneratedAccessToken: "No generated access token",
    generatedAccessTokenIsDisabled:
      "Generated access token is disabled when no user is selected",
    clientList: "Clients",
    clientsList: "Clients list",
    initialAccessToken: "Initial access token",
    clientSettings: "Client details",
    selectEncryptionType: "Select Encryption type",
    generalSettings: "General Settings",
    capabilityConfig: "Capability config",
    clientsExplain:
      "Clients are applications and services that can request authentication of a user",
    explainBearerOnly:
      "This is a special OIDC type. This client only allows bearer token requests and cannot participate in browser logins.",
    createSuccess: "Client created successfully",
    createError: "Could not create client: '{{error}}'",
    clientImportError: "Could not import client: {{error}}",
    clientSaveSuccess: "Client successfully updated",
    clientSaveError: "Client could not be updated:",
    clientImportSuccess: "Client imported successfully",
    clientDelete: "Delete {{clientId}} ?",
    clientDeletedSuccess: "The client has been deleted",
    clientDeleteError: "Could not delete client: {{error}}",
    clientDeleteConfirmTitle: "Delete client?",
    disableConfirmTitle: "Disable client?",
    downloadAdapterConfig: "Download adapter config",
    disableConfirm:
      "If you disable this client, you cannot initiate a login or obtain access tokens.",
    clientDeleteConfirm:
      "If you delete this client, all associated data will be removed.",
    searchInitialAccessToken: "Search token",
    createToken: "Create initial access token",
    tokenDeleteConfirm:
      "Are you sure you want to permanently delete the initial access token {{id}}",
    tokenDeleteConfirmTitle: "Delete initial access token?",
    tokenDeleteSuccess: "initial access token created successfully",
    tokenDeleteError: "Could not delete initial access token: '{{error}}'",
    timestamp: "Created date",
    created: "Created",
    lastUpdated: "Last updated",
    expires: "Expires",
    count: "Count",
    remainingCount: "Remaining count",
    expiration: "Expiration",
    noTokens: "No initial access tokens",
    noTokensInstructions:
      'You haven\'t created any initial access tokens. Create an initial access token by clicking "Create".',
    tokenSaveSuccess: "New initial access token has been created",
    tokenSaveError: "Could not create initial access token {{error}}",
    initialAccessTokenDetails: "Initial access token details",
    copyInitialAccessToken:
      "Please copy and paste the initial access token before closing as it can not be retrieved later.",
    clientAuthentication: "Client authentication",
    authentication: "Authentication",
    authenticationFlow: "Authentication flow",
    standardFlow: "Standard flow",
    directAccess: "Direct access grants",
    serviceAccount: "Service accounts roles",
    enableServiceAccount: "Enable service account roles",
    assignRolesTo: "Assign roles to {{client}} account",
    searchByRoleName: "Search by role name",
    filterByOrigin: "Filter by Origin",
    realmRoles: "Realm roles",
    clients: "Clients",
    assign: "Assign",
    roleMappingUpdatedSuccess: "Role mapping updated",
    roleMappingUpdatedError: "Could not update role mapping {{error}}",
    displayOnClient: "Display client on screen",
    consentScreenText: "Client consent screen text",
    loginSettings: "Login settings",
    accessSettings: "Access settings",
    rootUrl: "Root URL",
    validRedirectUri: "Valid redirect URIs",
    samlCapabilityConfig: "SAML capabilities",
    signatureAndEncryption: "Signature and Encryption",
    nameIdFormat: "Name ID format",
    forceNameIdFormat: "Force name ID format",
    forcePostBinding: "Force POST binding",
    forceArtifactBinding: "Force artifact binding",
    includeAuthnStatement: "Include AuthnStatement",
    includeOneTimeUseCondition: "Include OneTimeUse Condition",
    optimizeLookup: "Optimize REDIRECT signing key lookup",
    signDocuments: "Sign documents",
    signAssertions: "Sign assertions",
    signatureKeyName: "SAML signature key name",
    canonicalization: "Canonicalization method",
    addRedirectUri: "Add valid redirect URIs",
    loginTheme: "Login theme",
    consentRequired: "Consent required",
    clientAuthenticator: "Client Authenticator",
    changeAuthenticatorConfirmTitle: "Change to {{clientAuthenticatorType}}",
    changeAuthenticatorConfirm:
      "If you change authenticator to {{clientAuthenticatorType}}, the keycloak database will be updated and you may need to download a new adapter configuration for this client",
    signedJWTConfirm:
      'You should configure JWKS URL or keys in the "Keys" tab to change the parameters of Signed JWT authenticator.',
    anyAlgorithm: "Any algorithm",
    clientSecret: "Client secret",
    regenerate: "Regenerate",
    confirmClientSecretTitle: "Regenerate secret for this client?",
    confirmClientSecretBody:
      "If you regenerate secret, the Keycloak database will be updated and you will need to download a new adapter for this client.",
    confirmAccessTokenTitle: "Regenerate registration access token?",
    confirmAccessTokenBody:
      "If you regenerate registration access token, the access data regarding the client registration service will be updated.",
    clientSecretSuccess: "Client secret regenerated",
    clientSecretError: "Could not regenerate client secret due to: {{error}}",
    signingKeysConfig: "Signing keys config",
    signingKeysConfigExplain:
      'If you enable the "Client signature required" below, you must configure the signing keys by generating or importing keys, and the client will sign their saml requests and responses. The signature will be validated.',
    encryptionKeysConfig: "Encryption keys config",
    encryptionKeysConfigExplain:
      'If you enable the "Encryption assertions" below, you must configure the encryption keys by generating or importing keys, and the SAML assertions will be encrypted with the client\'s public key using AES.',
    enableClientSignatureRequired: 'Enable "Client signature required"?',
    enableClientSignatureRequiredExplain:
      'If you enable "Client signature required", the adapter of this client will be updated. You may need to download a new adapter for this client. You need to generate or import keys for this client otherwise the authentication will not work.',
    selectMethod: "Select method",
    selectMethodType: {
      generate: "Generate",
      import: "Import",
    },
    confirm: "Confirm",
    browse: "Browse",
    importKey: "Import key",
    disableSigning: 'Disable "{{key}}"',
    disableSigningExplain:
      'If you disable "{{key}}", the Keycloak database will be updated and you may need to download a new adapter for this client.',
    reGenerateSigning: "Regenerate signing key for this client",
    reGenerateSigningExplain:
      "If you regenerate signing key for client, the Keycloak database will be updated and you may need to download a new adapter for this client.",
    registrationAccessToken: "Registration access token",
    accessTokenSuccess: "Access token regenerated",
    accessTokenError: "Could not regenerate access token due to: {{error}}",
    signatureAlgorithm: "Signature algorithm",
    subject: "Subject DN",
    searchForClient: "Search for client",
    advanced: "Advanced",
    revocation: "Revocation",
    clustering: "Clustering",
    notBefore: "Not before",
    setToNow: "Set to now",
    noAdminUrlSet:
      "No push sent. No admin URI configured or no registered cluster nodes available",
    notBeforeSetToNow: "Not Before set for client",
    notBeforeNowClear: "Not Before cleared for client",
    notBeforePushFail: 'Failed to push "not before" to: {{failedNodes}}',
    notBeforePushSuccess: 'Successfully push "not before" to: {{successNodes}}',
    testClusterFail:
      "Failed verified availability for: {{failedNodes}}. Fix or unregister failed cluster nodes and try again",
    testClusterSuccess:
      "Successfully verified availability for: {{successNodes}}",
    deleteNode: "Delete node?",
    deleteNodeBody:
      'Are you sure you want to permanently delete the node "{{node}}"',
    deleteNodeSuccess: "Node successfully removed",
    deleteNodeFail: "Could not delete node: '{{error}}'",
    addedNodeSuccess: "Node successfully added",
    addedNodeFail: "Could not add node: '{{error}}'",
    addNode: "Add node",
    push: "Push",
    clear: "Clear",
    nodeReRegistrationTimeout: "Node Re-registration timeout",
    registeredClusterNodes: "Registered cluster nodes",
    nodeHost: "Node host",
    noNodes: "No nodes registered",
    noNodesInstructions:
      "There are no nodes registered, you can add one manually.",
    lastRegistration: "Last registration",
    testClusterAvailability: "Test cluster availability",
    registerNodeManually: "Register node manually",
    fineGrainOpenIdConnectConfiguration:
      "Fine grain OpenID Connect configuration",
    fineGrainSamlEndpointConfig: "Fine Grain SAML Endpoint Configuration",
    accessTokenSignatureAlgorithm: "Access token signature algorithm",
    idTokenSignatureAlgorithm: "ID token signature algorithm",
    idTokenEncryptionKeyManagementAlgorithm:
      "ID token encryption key management algorithm",
    idTokenEncryptionContentEncryptionAlgorithm:
      "ID token encryption content encryption algorithm",
    userInfoSignedResponseAlgorithm: "User info signed response algorithm",
    requestObjectSignatureAlgorithm: "Request object signature algorithm",
    requestObjectRequired: "Request object required",
    requestObject: {
      "not required": "Not required",
      "request or request_uri": "Request or Request URI",
      "request only": "Request only",
      "request_uri only": "Request URI only",
    },
    openIdConnectCompatibilityModes: "Open ID Connect Compatibly Modes",
    excludeSessionStateFromAuthenticationResponse:
      "Exclude Session State From Authentication Response",
    assertionConsumerServicePostBindingURL:
      "Assertion Consumer Service POST Binding URL",
    assertionConsumerServiceRedirectBindingURL:
      "Assertion Consumer Service Redirect Binding URL",
    logoutServicePostBindingURL: "Logout Service POST Binding URL",
    logoutServiceRedirectBindingURL: "Logout Service Redirect Binding URL",
    logoutServiceArtifactBindingUrl: "Logout Service ARTIFACT Binding URL",
    artifactBindingUrl: "Artifact Binding URL",
    artifactResolutionService: "Artifact Resolution Service",
    advancedSettings: "Advanced Settings",
    assertionLifespan: "Assertion Lifespan",
    accessTokenLifespan: "Access Token Lifespan",
    oAuthMutual: "OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled",
    keyForCodeExchange: "Proof Key for Code Exchange Code Challenge Method",
    authenticationOverrides: "Authentication flow overrides",
    browserFlow: "Browser Flow",
    directGrant: "Direct Grant Flow",
    jwksUrlConfig: "JWKS URL configs",
    keysIntro:
      'If "Use JWKS URL switch" is on, you need to fill a valid JWKS URL. After saving, admin can download keys from the JWKS URL or keys will be downloaded automatically by Keycloak server when see the stuff signed by the unknown KID',
    useJwksUrl: "Use JWKS URL",
    certificate: "Certificate",
    jwksUrl: "JWKS URL",
    generateNewKeys: "Generate new keys",
    generateKeys: "Generate keys?",
    generate: "Generate",
    archiveFormat: "Archive format",
    keyAlias: "Key alias",
    keyPassword: "Key password",
    storePassword: "Store password",
    generateSuccess: "New key pair and certificate generated successfully",
    generateError: "Could not generate new key pair and certificate {{error}}",
    import: "Import",
    importFile: "Import file",
    importSuccess: "New certificate imported",
    importError: "Could not import certificate {{error}}",
    tokenLifespan: {
      expires: "Expires in",
      never: "Never expires",
    },
    mappers: "Mappers",
  },
};
